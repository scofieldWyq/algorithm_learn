### 数组

关于数组来说，最常用的方式是

```java
// 创建
type[] array = new type[];
// 使用 元素定位：base_addr + type_size * index
array[index] = ?;
type var = array[index];
```

> 二维数组(Array[n][m])来说，元素定位是：`base_addr + type_size * (m * n + index)`

> 最基本的数组数据结构处理：插入(insert)、删除(delete)、随机查询(arr[index])

**最方便**：`随机查询`
**最低效**：`插入`和`删除`

> **Note**: 使用数组最大的诱惑就是能够随机访问(`能够方便的 arr[index]`),但是由于为了
> 保证数组数据连续性和有限空间的条件，往往在插入和删除的时候，都会伴随着要去维护这些条件
> 而产生的高代价导致了数组在这方面操作的"低效"。

> 然而，为了数组的随机访问，一般都都是考虑如何去优化这些低效操作。


#### 1.1. 保持数组空间的有序性

> 一般来说，为了保持数组空间有序性，然后就会通过一定策略(*什么时候要扩大空间量，什么时候缩小空间量*)来对数组进行空间的 `伸缩`。

**两倍空间伸缩策略（我自己起的，多当真，实际上就是依据 2 倍空间 size 来进行空间的伸缩）**

```java
// 定义了伸缩的接口
public interface TelescopicStrategy {
    int stretch(); // 伸展
    int shrink(); // 收缩
}
// 一般就是添加之前进行一次伸展操作，删除后进行一次收缩操作
@Override
public int stretch() {
    if(arr == null ||  size + 1 >=  arr.length) {
        // 伸展
        int stretchLength = size * 2;
        if(stretchLength == 0) {
            stretchLength = 2;
        }

        Object[] arrBak = new Object[stretchLength];
        if(arr != null)
            System.arraycopy(arr, 0, arrBak, 0, arr.length);

        arr = arrBak;
    }

    return arr.length;
}

@Override
public int shrink() {
    if(size > 2 && 2 * size < arr.length) {
        // 收缩
        Object[] arrBak = new Object[arr.length / 2];
        System.arraycopy(arr, 0, arrBak, 0, size);
        arr = arrBak;
    }

    return arr.length;
}
```

> 通过`伸缩策略`，让我们不用担心数组是一个不需要管空间是否够不够的问题。策略有很多种，但是主要还是
> 为了减少数组的操作的时候数组发生伸缩的次数，主要优化就是这个部分.


#### 1.2. 保持数组数据的连续性

> 数组为了保持数据的连续性，在数组插入和删除的时候，就会出现低效的操作行为。就是需要恢复数组的
> 数组的连续性，不然如果数组出现数据空洞的话，就会出现数据丢失且失去了随机访问的特性了。

##### 1.2.1. 插入

> 插入元素到指定的位置(i)的时候，需要将i和后面的数据向后进行一次数据迁移。

> 需要考虑两个情况，如果数据是有序的，那就别想了。一定是这样的 $O(n)$(别想着插入后排序，因为不能比 $O(n)$ 小的排序时间出现)。如果数据的有序性不需要考虑的话，那么就
> 可以考虑将 $O(n)$ 变为 $O(1)$ 的操作了。

**如果数据是无序的，那么比较好的一个解决方法就是将插入的元素的位置`i`的元素当作数组最后一个元素添加的方式处理**。

```java
public void insert(T ele, int index) {
    if(index < 0 || index > size) {
        return ;
    }

    T ele1 = (T)arr[index];
    size++;

    // 开始处理
    stretch();
    arr[index] = ele;
    arr[size - 1] = ele1;
}
```

##### 1.2.2. 删除

> 删除的时候，还是需要将被删除元素后面的元素向前面移动。如果有序的话，那就别想了，同样的 $O(n)$。如果不考虑数据的有序性，那么就可以进行优化，
> 优化的就是延缓或者不让 $O(n)$ 的发生，一下针对数据无序性来进行。

**$O(1) 的删除策略$**
```java
// 这个方式应该是最简单的方式了，但是会影响数据的有序性，如果不要求数据的有序性
// 大可不用担心 size effect
public void rem(T e) {
    int i = indexOf(e);
    arr[i] = arr[--size];
    shrink(); // 收缩数组
}
```

**标记删除策略**

> 标记删除策略主要还是针对元素来进行处理，属于元素级别的删除策略。所以需要元素的结构比较复杂一些来记录删除的标志位

**后面还有。。。，有再更新**


### 2. 支持伸缩的数组

>   普通的数组是固定的，这样数组如果面对变化的数据增长和减少来说，就会有空间不够用的问题。一般使用数据都会潜意识的认为 `数组是无限长度的`，
> 这样我们就不用关心数组越界的问题。

为了保证数组的数据连续性，在插入和删除数据的时候，就得需要对元素进行整体的移动，这个是数组在操作数据上的`短板`。但是数组快速的随机访问能力，
让它可以被忽略短板地使用。

所以我们一直都在解决数组使用的问题是

    1. 如何减少数据空间伸缩带来的性能缺失
    2. 在更好的使用数组快速和连续访问的性能基础上，如何减少数据迁移带来的损耗

数据空间的伸缩在所难免，但是它一旦发生，就是性能的`毁灭（相对没有发生伸缩的case）`，如果频繁插入和删除，也会影响到
数组的性能，同样也是`毁灭`的时刻。

这里说的毁灭有点严重了。但是缺失这个就是让数组性能严重降低的原因。

所以，数组不好还是硬着头皮使用的时候，也要合理地分摊掉最坏的情况

#### 2.1. 永远都有空间的数组（相对来说）

> 为了让数组的使用过程中，不用关心数组是否空间不足的问题，需要对数据进行空间伸缩 - `SpaceFlexibleArray`

